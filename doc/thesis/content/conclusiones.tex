\section{CONCLUSIONES}

\subsection{Resultados}

El resultado más importante que se obtuvo es una aplicación \footnote {Referencias: Objetivo General} que centraliza en un solo punto los procesos de almacenamiento de información, edición de código, compilación y administración de las versiones de los archivos, facilitando la integración con máquinas clientes de bajas prestaciones y cuyo único requisito es que tenga instalado cualquiera de los sistemas operativos modernos.

Se seleccionaron las siguientes tecnologías \footnote {Referencias: Tecnologías Utilizadas} para el desarrollo de la aplicación:

\begin{itemize}
	
	\item Arquitectura: SOA
	\footnote {Referencias: Tecnologías Utilizadas: SOA - Objetivos Específicos: 3}
	
	\item Framework de desarrollo RIA: QooXdoo
	\footnote {Referencias: Tecnologías Utilizadas: QooXdoo - Objetivos Específicos: 3}
	
	\item Lenguaje de enfoque para el IDE: Java
	\footnote {Referencias: Tecnologías Utilizadas: Java - Objetivos Específicos: 2 y 4}
	
	\item Formato de comunicacion cliente-servidor: JSON
	\footnote {Referencias: Tecnologías Utilizadas: JSON - Objetivos Específicos: 1}
	
	\item Lenguaje de construccion del servidor: Ruby
	\footnote {Referencias: Tecnologías Utilizadas: Ruby - Objetivos Específicos: 3}
	
	\item Sistema de despacho de peticiones (servidor): Proxy Inverso Pound
	\footnote {Referencias: Tecnologías Utilizadas: Pound - Objetivos Específicos: 3}
	
	\item Sistema de intercambio de archivos: WebDAV
	\footnote {Referencias: Tecnologías Utilizadas: WebDAV - Objetivos Específicos: 1}
	
\end{itemize}


Como resultados adicionales la aplicación permite:

\begin{itemize}
	
	\item Creación, eliminación y configuración de usuarios.
	
	\item Creación y eliminación de repositorios de código fuente SVN (SubVersioN).
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Creación y eliminación de copias de trabajo SVN (SubVersioN).
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Administración (mover, copiar, eliminar, crear) de archivos y directorios utilizando una vista de árbol de archivos.
	
	\item Edición de código fuente WYSIWYG(What You See Is What You Get).
	\footnote {Referencias: Objetivos Específicos: 4}
	
	\item Edición concurrente de código fuente instanciando el editor en múltiples tabs
	\footnote {Referencias: Objetivos Específicos: 4}
	
	\item Compilación de código en lenguaje Java.
	\footnote {Referencias: Tecnologías Utilizadas: Java - Objetivos Específicos: 2 y 5}
	
	\item Creación de nuevas versiones de los proyectos.
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Consulta inteligente del estado de los proyectos (árbol de archivos y contenido de archivos) en otras versiones.
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Acceso a los datos de configuración, los repositorios y las copias de trabajo de los usuarios vía WebDAV.
	\footnote {Referencias: Tecnologías Utilizadas: WebDAV - Objetivos Específicos: 1}
	
\end{itemize}

Además de todo esto el proceso de desarrollo de la aplicación permite que cualquier persona continúe con el trabajo debido a la documentación generada y a la claridad de la implementación.


\subsection{Trabajos Futuros}

Como trabajos futuros principalmente se plantea que el producto adquiera un nivel mayor de estabilidad para que pueda ser catalogado como producto de calidad de producción.\newline Otras mejoras planteadas son:

\paragraph{Módulo de control de versiones:}

\begin{itemize}
	\item Crear un plugin que permita utilizar un manejador de versiones distribuido, entre los manejadores de versiones distribuidos se encuentran: GIT, Darcs, Mercurial(HG), Bazaar, etc.
\end{itemize}

\paragraph{Módulo de GUI:}

\begin{itemize}
	\item Hacer que el editor muestre resaltado de sintaxis del código fuente.
	\item Crear en el editor un mecanismo de autoindentación.
	\item Crear en el editor un sistema que permita hacer sugerencias y completado de palabras de forma automática.
\end{itemize}

\paragraph{Módulo de Compilación:}

\begin{itemize}
	\item Resaltar en el editor las líneas donde se detectaron los errores de compilación.
	\item Crear un plugin de compilación para otros lenguajes como pueden ser C++, Java, etc.
\end{itemize}

\paragraph{Módulo de WebServices:}

\begin{itemize}
	\item Modificar el sistema de webservices para que sea compatible con el estándar JSON-RPC. \cite{json-rpc}
\end{itemize}

\paragraph{Módulo de Listeners:}

\begin{itemize}
	\item Crear un módulo que permita despachar los archivos estáticos por medio de servidores más utilizados como Lighttp \cite{lighttp} o Apache \cite{apache}.
\end{itemize}


\subsection{Experiencias Obtenidas}

Quizá la mayor experiencia obtenida durante el desarrollo de este proyecto fue el de poder experimentar en carne propia las metodologías de desarrollo de software existentes y poder ver su alto grado de inmadurez, incluso en metodologías ampliamente utilizadas como la propuesta de IBM Rational el RUP(Rational Unified Process).

De acuerdo a mi experiencia es humanamente imposible pensar en las consecuencias que puede traer un diseño previo bastante elaborado de un desarrollo de software, teniendo como restricción que el tiempo de diseño sea igual al tiempo de construcción, es por esto que no tiene sentido demorarse en especificaciones y declaraciones de como se van a realizar las cosas, más concretamente hablando de los diagramas de secuencia y de colaboración

Las verdaderas consecuencias del diseño son sólo medibles con heurísticas aceptables cuando se procede con la implementación real del software debido a que intervienen ciertos factores en el proceso de desarrollo que son muy influyentes y muy estocásticos lo que conlleva a problemas que simplemente no se tuvieron en cuenta en el momento del diseño, otro efecto que surge es el amarre de estos factores con el diseño moldeándolo y forzándolo a tener un enfoque cerrado a ciertas características, estos factores son:

\paragraph{El lenguaje de programación:}
Es posible encontrarse con muchos lenguajes de programación, en la actualidad existen aproximadamente 2500 \cite{bd_lenguajes_programacion}, sin contar los lenguajes de uso personal y los lenguajes para entornos muy específicos, de acuerdo con lo anterior podemos entonces afirmar que existen lenguajes de programación de todos los colores y sabores y así mismo cada uno tiene sus propias características, habilidades, herramientas, soporte, paradigmas y lo mas importante de todo el enfoque, algo que hace que la solución cambie de forma radical e incluso, en algunos casos, hace que la solución sea algo inalcanzable. \newline De esto se concluye que el diseño de la solución de un problema varía de acuerdo a las características del lenguaje.


\paragraph{Las herramientas a utilizar:}
Este concepto se puede observar mejor en el ámbito de las aplicaciones web, un campo que ha soportado una revolución desde el punto de vista de las ayudas y facilidades para el desarrollador, en donde han surgido herramientas de gran envergadura conocidas como frameworks que automatizan procesos como: las conexiones a base de datos, el deployment (de desarrollo, pruebas y producción), las pruebas unitarias, la organización del proyecto, etc. Cada uno de estos frameworks crean dependencias que obligan a hacer las cosas de cierta forma(ej: en ruby on rails se debe seguir una arquitectura modelo-vista-controlador), cambiando de forma radical el diseño de nuestra aplicación.

\paragraph{Las bibliotecas disponibles:}
Una biblioteca no es más que una implementación de un concepto de programación, entre más y mejores bibliotecas dispongamos para nuestro lenguaje más fácil nos resultará hacer las cosas, un ejemplo muy simple es sistema de autenticación ya que generalmente se requiere la implementación de algún sistema de cifrado, si no disponemos de una buena implementación es posible que busquemos otras alternativas como utilizar las bibliotecas de otro lenguaje lo que requeriría crear un sistema de comunicación entre ambos lenguajes o simplemente implementar el algoritmo aumentando la complejidad del software a producir las cuales cambian nuestro diseño de una forma u otra.

\paragraph{Las tecnologías asociadas:}
Generalmente en la programación de software existen muchas formas de hacer las cosas que dependen incluso de la época en la que nos encontremos, el ejemplo más claro es que hace unos 10 años la mayoría de la programación seguía un paradigma funcional, hoy la media es utilizar sistemas orientados a objetos y es muy posible que para mañana se utilicen herramientas basadas en la concurrencia de los procesos como el paradigma de los agentes o el de restricciones.


Desde luego estas afirmaciones también tienen sus limites ya que simplemente lanzarse a programar la solución, traeará problemas que entre los más importantes están la perdida de trabajo y la creación de software poco expansible y cerrado.

Por estas razones mi propuesta para la realización de este proyecto se resume en la declaración de un punto intermedio en donde se describa el problema y los resultados esperados y en donde el diseño sea adaptable (fácil de modificar) y cuyo límite de detalle sea el punto en donde se pueda escoger cualquiera de las variantes de los factores mencionados anteriormente sin que se vea reflejado en un cambio en el diseño.\newline Lo principal de este diseño es diferenciar y describir, pero no detallar, los sistemas que componen la aplicación (ej: sistema de control de usuarios, sistema de envío de la información, etc), luego de esto se procede con la realización de la aplicación (programación) en donde los detalles de la implementación se describan dentro del propio código (no en diagramas de colaboración o de secuencia), y en donde los resultados sufran un proceso de reingeniería hasta lograr una solución estable que satisfaga los resultados esperados.

Otras experiencias obtenidas se basan en la adquisición de nuevos conocimientos y dominio de diversas tecnologías, estas son:

\begin{itemize}
	\item Ruby.
	\item Ruby on Rails.
	\item JSON.
	\item XML.
	\item JavaScript.
	\item HTML.
	\item CSS.
	\item AJAX.
	\item Control de versiones.
	\item Lenguajes de programación.
\end{itemize}

