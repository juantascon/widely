\section{CONCLUSIONES}

\subsection{Resultados}

El resultado mas importante que se obtuvo es una aplicación (Ver: Objetivo General Sección \ref{objetive:general}) que centraliza en un solo punto el proceso de almacenamiento de información, edición de código, compilación y administración de las versiones de los archivos, facilitando la integración con maquinas clientes de bajas prestaciones y como único requisito que tenga instalado cualquiera de los sistemas operativos modernos.

Se seleccionaron las siguientes tecnologías para el desarrollo de la aplicación (Ver: Tecnologías Utilizadas Sección \ref{tec:all}):

\begin{itemize}
	
	\item Arquitectura: SOA
	\footnote {Referencias: Tecnologías Utilizadas: SOA - Objetivos Específicos: 3}
	
	\item Framework de desarrollo RIA: QooXdoo
	\footnote {Referencias: Tecnologías Utilizadas: QooXdoo - Objetivos Específicos: 3}
	
	\item Lenguaje de enfoque para el IDE: Java
	\footnote {Referencias: Tecnologías Utilizadas: Java - Objetivos Específicos: 2 y 4}
	
	\item Formato de comunicacion cliente-servidor: JSON
	\footnote {Referencias: Tecnologías Utilizadas: JSON - Objetivos Específicos: 1}
	
	\item Lenguaje de construccion del servidor: Ruby
	\footnote {Referencias: Tecnologías Utilizadas: Ruby - Objetivos Específicos: 3}
	
	\item Sistema de despacho de peticiones (servidor): Proxy Inverso Pound
	\footnote {Referencias: Tecnologías Utilizadas: Pound - Objetivos Específicos: 3}
	
	\item Sistema de intercambio de archivos: WebDAV
	\footnote {Referencias: Tecnologías Utilizadas: WebDAV - Objetivos Específicos: 1}
	
\end{itemize}


Como resultados adicionales la aplicación web IDE permite:

\begin{itemize}
	
	\item Creación eliminación y configuración de usuarios.
	
	\item Creación y eliminación de repositorios de código fuente SVN (SubVersioN).
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Creación y eliminación de copias de trabajo SVN (SubVersioN).
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Administración (mover, copiar, eliminar, crear) de archivos y directorios utilizando una vista de árbol de archivos.
	
	\item Edición de código fuente wysiwyg(What You See Is What You Get).
	\footnote {Referencias: Objetivos Específicos: 4}
	
	\item Edición concurrente de código fuente instanciando el editor en múltiples tabs
	\footnote {Referencias: Objetivos Específicos: 4}
	
	\item Compilación de código en lenguaje Java.
	\footnote {Referencias: Tecnologías Utilizadas: Java - Objetivos Específicos: 2 y 5}
	
	\item Creación de nuevas versiones de proyecto.
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Consulta inteligente del estado de proyectos (árbol de archivos y contenido de archivos) en otras versiones.
	\footnote {Referencias: Objetivos Específicos: 5}
	
	\item Acceso a los datos de configuración, repositorios y copias de trabajo de los usuarios vía WebDAV.
	\footnote {Referencias: Tecnologías Utilizadas: WebDAV - Objetivos Específicos: 1}
	
\end{itemize}

Ademas de todo esto el proceso de desarrollo de la aplicación permite que cualquier persona continúe con el trabajo debido a la documentación generada y a la claridad de la implementación


\subsection{Trabajos Futuros}

Como trabajos futuros principalmente se plantea que el producto adquiera un nivel mayor de estabilidad para que pueda ser catalogado como producto de calidad de produccion.

Otras mejoras planteadas son:

\paragraph{Modulo de control de versiones:}

\begin{itemize}
	\item Crear un plugin que permita utilizar un manejador de versiones distribuido, entre los manejadores de versiones distribuidos se encuentran: GIT, DARCS, Mercurial(HG), Bazaar, etc
\end{itemize}

\paragraph{Modulo de GUI:}

\begin{itemize}
	\item Hacer que el editor muestre resaltado de sintaxis del código fuente.
	\item Crear en el editor un mecanismo de autoindentación.
	\item Crear en el editor un sistema que permita hacer sugerencias y completado de palabras automático
\end{itemize}

\paragraph{Modulo de Compilación:}

\begin{itemize}
	\item Resaltar en el editor las lineas donde se detectaron los errores de compilación
	\item Crear un plugin de compilación para otros lenguajes como pueden ser c++, java, etc
\end{itemize}

\paragraph{Modulo de WebServices:}

\begin{itemize}
	\item Modificar el sistema de webservices para que sea compatible con el estándar JSON-RPC \cite{json-rpc}
\end{itemize}

\paragraph{Modulo de Listeners:}

\begin{itemize}
	\item Crear un módulo que permita despachar los archivos estáticos por medio de servidores mas utilizados como Lighttp \cite{lighttp} o Apache \cite{apache}
\end{itemize}


\subsection{Experiencias Obtenidas}

Quizá la mayor experiencia obtenida durante el desarrollo de este proyecto fue el de poder vivir en carne propia las metodologías de desarrollo de software existentes y poder ver su alto grado de inmadurez, incluso en metodologías ampliamenteampliamente utilizadas como la propuesta de IBM Rational el RUP(Rational Unified Process).

De acuerdo a mi experiencia es humanamente imposible pensar en las consecuencias que puede traer un diseño previo de un desarrollo de software bastante elaborado, teniendo como limite de tiempo el mismo tiempo que se va a gastar en la implementación, es por esto que no tiene sentido gastar tiempo valioso en especificaciones y declaraciones de como se van a realizar las cosas, mas específicamente hablando de los diagramas de secuencia y de colaboración

Las verdaderas consecuencias del diseño son solo medibles con heurísticas aceptables cuando se procede la implementación real del software debido a que intervienen ciertos factores en el proceso de desarrollo que son muy influyentes y muy estocásticos por lo que se reflejan en problemas que simplemente no se tuvieron en cuenta en el momento del diseño del software, otro efecto que surge es el amarre de estos factores con el diseño moldeándolo y produciendo un diseño con un enfoque cerrado a ciertas características, estos factores son:

\paragraph{El lenguaje de programación:}
Es posible encontrarse con muchos lenguajes de programación, en la actualidad se cree que existen aproximadamente 2500 \cite{bd_lenguajes_programacion} sin contar los lenguajes de uso personal y los lenguajes para entornos muy específicos, de acuerdo con lo anterior podemos entonces afirmar que existen lenguajes de programación de todos los colores y sabores y así mismo cada uno tiene sus propias características, habilidades, herramientas, soporte y paradigmas, de esto se concluye que la formulación de la solución de un problema varia de acuerdo a las características del lenguaje.


\paragraph{Las herramientas a utilizar:}
Este concepto se puede observar mejor en el ámbito de las aplicaciones web, un campo que ha soportado una revolución desde el punto de vista de las ayudas y facilidades para el desarrollador, en donde han surgido herramientas de gran envergadura conocidas como frameworks que automatizan procesos como: las conexiones a base de datos, el deployment (de desarrollo, pruebas y producción), las pruebas unitarias, la organización del proyecto, etc. Cada uno de estos frameworks crean dependencias que obligan hacer las cosas de cierta forma(ej: en ruby on rails se debe seguir una arquitectura modelo-vista-controlador), cambiando de forma radical el diseño de nuestra aplicación

\paragraph{Las bibliotecas disponibles:}
Una biblioteca no es mas que una implementación de un concepto de programación, entre mas y mejores bibliotecas dispongamos para nuestro lenguaje mas fácil se nos resultaran hacer las cosas, un ejemplo muy simple es el de el sistema de autenticación ya que generalmente se requiere la implementación de algún sistema de cifrado, si no disponemos de una buena implementación es posible que busquemos otras alternativas que cambian nuestro diseño como utilizar las de otro lenguaje lo que requeriría crear un sistema de comunicación entre ambos lenguajes o simplemente implementar el algoritmo aumentando la complejidad del software a producir.

\paragraph{Las tecnologías asociadas:}
generalmente en la programación de software existen muchas formas de hacer las cosas que dependen incluso de la época en la que nos encontremos, el ejemplo mas claro es que hace unos 10 años la mayoría de la programación seguía un paradigma funcional, hoy la media es utilizar sistemas orientados a objetos y es muy posible que para mañana se utilicen herramientas basadas en la concurrencia de los procesos como el paradigma de los agentes o el de restricciones.


Desde luego estas afirmaciones también tienen sus limites ya que simplemente lanzarse a programar la solución, traeará problemas que entre los mas importantes están la perdida de trabajo y la creación de software poco expansible y cerrado.

Mi propuesta para resolver estos problemas se resume en la declaración de un punto intermedio en donde se describa el problema y los resultados esperados y en donde el diseño sea amortiguable(fácil de modificar) y cuyo limite de detalle sea el punto en donde se pueda escoger cualquiera de las variantes de los factores mencionados anteriormente sin que se vea reflejado en un cambio en el diseño, lo principal de este diseño es diferenciar y describir pero no detallar los sistemas que componen la aplicación (ej: sistema de control de usuarios, sistema de envío de la información, etc), luego de esto se procede con la realización de la aplicación (programación) en donde los detalles de la implementación se describan dentro del propio código (no en diagramas de colaboración o de secuencia), y en donde los resultados sufran un proceso de reingeniería hasta lograr una solución estable que satisfaga los resultados esperados.

Otras experiencias obtenidas se basan en la adquisición de nuevos conocimientos y dominio de diversas tecnologías, estas son:

\begin{itemize}
	\item Ruby
	\item Ruby on Rails
	\item JSON
	\item XML
	\item JavaScript
	\item HTML
	\item CSS
	\item AJAX
	\item Control de versiones
	\item Lenguajes de programacion
\end{itemize}
