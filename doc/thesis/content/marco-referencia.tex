\section{MARCO DE REFERENCIA}

\subsection{Tecnologías Implementadas}

\label{tec:all}

\subsubsection{RIA (Rich Internet Application)}
\label{tec:ria}

Rich Internet Applications o Aplicaciones Ricas de Internet son aplicaciones web que tienen funcionalidades propias de las tradicionales aplicaciones de escritorio. Usualmente las RIAs transfieren el procesamiento necesario para la interfaz del usuario al cliente web pero mantienen la parte lógica y de procesamiento de los datos en el servidor de la aplicación.

Generalmente las RIAs:

\begin{itemize}
	
	\item Son ejecutadas en un navegador web y no necesitan instalación adicional de software.
	
	\item Son ejecutadas localmente en un entorno seguro.
	
\end{itemize}

Los métodos, técnicas o lenguajes utilizadas para desarrollar RIAs son:

\begin{itemize}
	\item JavaScript
	\item Macromedia Flash
	\item Controles ActiveX
	\item Applets de Java
	\item Lenguajes de Interfaz de Usuario (ej: XUL).
\end{itemize}

\subsubsection{SOA (Service Oriented Arquitecture)}
\label{tec:soa}

SOA \cite{soa} (Arquitectura Orientada a Servicios) es una evolución de la computación distribuida, SOA provee modularidad en la lógica de negocios que puede ser representada como servicios para los clientes, estos servicios tienen bajo acoplamiento, en el sentido en que la interfaz de usuario(GUI) puede permanecer totalmente independiente de la lógica de negocio.

OASIS (Organization for the Advancement of Structured Information Standards) define SOA de la siguiente manera: ``Es un paradigma para organizar y utilizar características distribuidas que pueden estar bajo el control de dominios diferentes. Provee un significado uniforme para ofrecer, descubrir, interactuar y utilizar estas características para producir los efectos deseados con precondiciones y expectativas medibles.'' \cite{oasis_soa}

SOA fue elegida principalmente por que provee división, modularidad y bajo acoplamiento dentro de la lógica de negocio y en la comunicación con la interfaz de usuario.


\subsubsection{Java}
\label{tec:java}

Java \cite{java} es un lenguaje de programación creado originalmente por Sun Microsystems.\newline Una aplicación Java normalmente se compila en un código máquina llamado bytecode (Codigo Byte), este código es ejecutado por una máquina virtual de Java, esta interpreta las instrucciones de la aplicación (bytecode) y las ejecuta en la máquina nativa, también es posible ejecutar estas aplicaciones de forma directa en un procesador Java.

Las características principales de Java \cite{java_caracteristicas} son:

\begin{enumerate}
	
	\item Orientado a Objetos: desde el comienzo uno de los objetivos de Java ha sido incorporar y fusionar dentro del núcleo principal las partes buenas de otros lenguajes de programación orientados a objetos.
	
	\item Multiplataforma: la máquina virtual de Java conocida también como JRE (Java RunTime Environment), está disponible para la mayoría de sistemas operativos.
	
	\item Fácil de aprender: su sintaxis proviene de lenguajes como C o C++, a diferencia de estos lenguajes, Java elimina algunos aspectos como la herencia múltiple o los punteros, facilitando el trabajo del programador evitando que cometa algunos errores. Como contraparte estas características, bien utilizadas, pueden llegar a ser herramientas muy poderosas que simplemente se han olvidado en el mundo de Java.
	
	\item Robusto: hace numerosas comprobaciones en tiempo de compilación y de ejecución, además de esto, Java elimina muchas de las características de otros lenguajes como C++, para mantener reducidas las especificaciones del lenguaje y añadir características muy útiles como el garbage collector (reciclador de memoria dinámica). No es necesario preocuparse por liberar memoria, este reciclador se encarga de ello y cuando entra en acción, permite liberar bloques de memoria muy grandes, reduciendo la fragmentación de la memoria.
	
\end{enumerate}

Para este proyecto se ha decidió implementar una interfaz con el compilador de Java de Sun Microsystems debido a su robustez y a su facilidad de control en el momento de la ejecución, además, como punto adicional Java es probablemente el lenguaje más popular en estos tiempos ya que ha sido adoptado en innumerables proyectos alrededor del mundo.


\subsubsection{JSON (JavaScript Object Notation)}
\label{tec:json}

JSON \cite{json} (Notación de Objecto en JavaScript) es un formato liviano de intercambio de datos, es más sencillo de leer y escribir para los humanos, además es fácil para una máquina analizarlo y generarlo, esta basado en un subconjunto del lenguaje de programación JavaScript (Standard ECMA-262 3rd Edition \cite{json_ecma}).

JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones familiares para los programadores que hayan utilizado lenguajes derivados del lenguaje C (C, C++, C\#, Java, Python, etc).\newline Por estas razones JSON se convierte en un lenguaje ideal para el intercambio de datos.

JSON es construido en dos estructuras:

\begin{itemize}

	\item Una colección de pares nombre/valor, esto es visto en varios lenguajes como un objeto, una estructura, un diccionario, una tabla hash, etc.
	
	\item Una Lista ordenada de valores, esto es visto en varios lenguajes como un array, un vector, una lista, etc.

\end{itemize}

Estas son estructuras de datos universales y gracias a que todos los lenguajes modernos las soportan de una forma u otra, tiene sentido que estas estructuras de datos que son intercambiable entre los lenguajes se utilicen precisamente para eso, intercambiar datos.

Ejemplo: Una lista de personas en JSON se vería así

\begin{verbatim}
[
 { ``nombre'': ``Juan'', ``apellido'': ``Tascon'' },
 { ``nombre'': ``Diego'', ``apellido'': ``Tascon'' },
 { ``nombre'': ``Jose'', ``apellido'': ``Vidarte'' }
]
\end{verbatim}

Por el hecho de que la mayoría de texto en formato JSON tienen una sintaxis válida en JavaScript, es posible para un programa JavaScript analizar los datos de forma nativa en este formato utilizando la función incorporada de JavaScript eval(), para este caso en lugar de utilizar un analizador especifico de JSON es el propio lenguaje el que se encarga de interpretar y ejecutar los datos para producir objetos nativos.

El uso de esta técnica puede ser segura siempre y cuando todo el entorno (los datos JSON y el programa JavaScript) esté bajo el control de una fuente confiable y única, sin embargo en el ambiente de un servidor web rara vez se tiene que todo provenga de una única fuente, abriendo el paso a posibles fallos de seguridad si no se utiliza con cuidado.

La principal ventaja que tiene sobre el formato XML es que no requiere realizar un analizador en el lenguaje JavaScript sino que este está incluido en el lenguaje mismo.\newline JSON está siendo adoptado a una velocidad tan rápida que quizá algún día haya reemplazado por completo a su rival más cercano XML.


\subsubsection{WebDAV}
\label{tec:webdav}

WebDAV \cite{webdav} es una extensión al protocolo HTTP 1.1 que permite realizar acciones de gestión sobre archivos tales como escribir, copiar, eliminar o modificar \cite{webdav_rfc}.

El objetivo de WebDAV se define por su lema ``Makes the Web Writable'' (hacer que la web sea escribible), esto permite hacer de la web un espacio de colaboración, donde varias personas distintas puedan participar conjuntamente en la elaboración de documentos.

Algunas de las características más destacadas de webdav (aparte de proporcionar acceso a la escritura del documento vía HTTP) son el locking o posibilidad de cerrar dicho acceso de escritura, un mecanismo imprescindible para un entorno de trabajo compartido, evitando, cuando se desee, que el trabajo nuevo de un usuario sobrescriba al del anterior. La posibilidad de describir propiedades (meta datos) del documento en formato XML, como titulo, asunto, autor, fecha, tamaño, que aunque no aparecen en el documento proporcionan información sobre el mismo y pueden ser fácilmente gestionados por el protocolo (permitiendo funciones de listado de datos, búsqueda inteligente, etc).

Con WebDav desaparecen las diferencias entre nuestro disco duro y el espacio web. Es mucho más practico para las empresas guardar sus documentos en servidores web desde donde podrán asegurar su inmediata disponibilidad de forma segura.

WebDAV añade los siguientes métodos a HTTP:

\begin{itemize}

	\item PROPFIND: Usado para recuperar propiedades de un recurso. También está sobrecargado para permitir recuperar la estructura de colección (la jerarquía de directorios) de un sistema remoto.
	
	\item PROPPATCH: Usado para cambiar y borrar múltiples propiedades de un recurso en una simple operación atómica (commit).
	
	\item MKCOL: Usado para crear colecciones (directorios).
	
	\item COPY: Usado para copiar un recurso desde un lugar a otro.
	
	\item MOVE: Usado para mover un recurso desde un lugar a otro.
	
	\item LOCK: Usado para bloquear (lock) un recurso.
	
	\item UNLOCK: Para desbloquear un recurso.

\end{itemize}

Recurso es el nombre HTTP para una referencia que está apuntada por un Identificador de Recursos Uniforme o URI (Uniform Resource Identifier).

El grupo de trabajo WebDAV \cite{ietf} está todavía trabajando en unas cuantas extensiones a WebDAV, incluyendo: control de redirecciones, enlaces, límites de espacio en disco y mejoras en la especificación base para que alcance el nivel de madurez del resto de estándares de Internet.

Las principales ventajas de WebDAV sobre otros sistemas de archivos de red son:

\begin{enumerate}

	\item Se puede acceder en modo solo lectura desde cualquier browser que soporte el protocolo HTTP 1.1.
	
	\item Todos los sistemas operativos modernos incluyen soporte para WebDAV.
	
	\item Es un estándar ampliamente utilizado \cite{webdav_rfc}.
	
	\item La implementación de un servidor es bastante sencillo, por esta misma razón es muy fácil empotrarlo en cualquier aplicación y adaptarlo para que sea compatible con un sistema de autenticación propio.
	
\end{enumerate}


\subsubsection{Ruby}
\label{tec:ruby}

Ruby \cite{ruby_lang} es un lenguaje de programación orientada a objetos e interpretado, creado por Yukihiro Matsumoto, que tiene una sintaxis inspirada en varios lenguajes de programación como Perl, Smalltalk, Python, C, Lisp, entre otros.

Las principales características de Ruby son:

\paragraph{Orientado a Objetos:}
En Ruby todos los datos son objetos, incluso las clases y los tipos de datos que en algunos lenguajes son manejados como datos primitivos (enteros, strings, etc), los valores con nombre(variables) siempre hacen referencia a los objetos, no son los objetos mismos. \newline Ruby soporta herencia, polimorfismo, tipado dinámico, mixins (definiciones de métodos y variables agrupados que se pueden incluir en la definición de clases y en los objetos), y métodos singletons (los métodos singletons son métodos que no solo son parte de las clases sino que también pueden pertenecer únicamente a una instancia).

\paragraph{Duck Typing:}
El termino Duck typing (tipado de pato) hace referencia a la prueba del pato (duck test) que dice que si un animal que camina como pato, nada como pato y grazna como pato, entonces se podría decir que ese animal es un pato.\newline Es un principio de los lenguajes de programación con tipado dinámico en donde el conjunto de métodos y propiedades de un objeto determina la semántica valida, en lugar de su herencia de una clase o un tipo de dato en particular.\newline Ejemplo:

\begin{verbatim}
def concatenar(a, b)
  unless a.respond_to?(:<<)
    raise ArgumentError.new("'a' no soporta el método <<")
  end
  a << b
end
\end{verbatim}

\paragraph{Introspección}:
Introspección de tipos es la capacidad de algunos lenguajes de programación orientados a objetos que permite determinar el tipo de un objeto en tiempo de ejecución. \newline Ejemplo:

\begin{verbatim}
def ver_tipo(a)
  print "el objeto es de tipo: "+ a.class
end
\end{verbatim}

\paragraph{Iteradores y Closures(bloques):}
En Ruby el llamado a métodos permite pasar un fragmento de código (bloque o closures) como parte de los parámetros de entrada del método, permitiendo definir iteradores basados en estos bloques de código.\newline Ejemplo:

\begin{verbatim}
['hola', 3, 'que hay'].each {|item| puts item}
# => hola
# => 3
# => que hay
\end{verbatim}

\paragraph{Expresiones Regulares Nativas:}
Ruby permite definición de expresiones regulares nativas en el lenguaje, de forma similar a como se hacen en el lenguaje perl.\newline Ejemplo:

\begin{verbatim}
"archivo.png".match(/^[a-z]*.png/)[0]
# => "archivo.png"
\end{verbatim}

\paragraph{Inyección de Dependencias:}
Inyección de dependencias describe una situación en donde un objeto utiliza a un segundo objeto para proveer una característica particular, por ejemplo pasando una conexión de base de datos como argumento en el constructor en lugar de crear uno internamente.\newline El termino ``Inyección de Dependencias'' no se refiere realmente a una dependencia que es inyectada sino que es un proveedor de alguna característica o recurso el que es inyectado.

\paragraph{Metaprogramacion:}
Metaprogramación se refiere a programas que tienen la habilidad de escribir o manipular otros programas(incluso a ellos mismos). En muchos casos esto permite a los programadores hacer más cosas en el mismo tiempo que hubiera tomado escribir el código de forma manual.\newline Ejemplo:

\begin{verbatim}
#! /usr/bin/env ruby
# metaprograma
file = File.new("./programa.rb", "w+")
file.puts "#! /usr/bin/env ruby'
[1..200].each { |n| file.puts "puts #{n}" }
\end{verbatim}

Este programa genera 200 lineas de un programa que muestra en pantalla los números desde el 0 hasta el 200.

\paragraph{Reflexión:}
Reflexión es la capacidad de un programa de observar y modificar su estructura interna.\newline Ejemplo:

\begin{verbatim}
Object.methods
# => ["inspect", "private_class_method", "const_missing", "clone", ... ]
\end{verbatim}

\paragraph{Continuaciones y generadores:}
Una continuación es un objeto que representa un punto en el programa, permitiendo que sea posible regresar allí en cualquier momento, incluso en los casos en los que la ejecución se encuentre en un ámbito diferente(ej: dentro de un método).

\paragraph{DRY(Don't Repeat Yourself):}
El principio No te repitas, es una filosofía de definición de procesos que promueve la reducción de la duplicación.\newline Según este principio ninguna pieza de información debería estar en dos partes distintas al mismo tiempo debido a que la duplicación incrementa la dificultad en el tratamiento de los cambios y evolución posterior, puede perjudicar la claridad y crea un espacio en donde se pueden encontrar posibles inconsistencias.\newline Cuando el principio DRY se aplica de forma eficiente, los cambios en cualquier parte del proceso requieren que estos cambios se hagan en un único lugar.

Como nota personal del autor la razón de mayor peso para escoger este lenguaje de programación para desarrollar el servidor en lugar de otros lenguajes más difundidos y conocidos en el mundo Web como PHP o Python, es que su sintaxis es muy cómoda y atractivo y está repleta de ``azucares sintácticos'', además de las muchas características únicas mencionadas anteriormente que hacen de Ruby uno de los lenguajes más potentes que se pueden encontrar por estos dias.


\subsubsection{Pound}
\label{tec:pound}

Pound \cite{pound} es un proxy inverso creado por Apsis IT Security, pound permite distrubución de carga basado en reglas de despacho definidas.\cite{pound}

Las soluciones actuales para despacho de información procesada a través de la web son:

La solución CGI (Common Gateway Interface), que implica realizar una comunicación entre el servidor web y la aplicación, esta comunicación se realiza levantando un proceso por cada petición al servidor, retornando la salida del programa CGI y utilizando los datos de la petición como datos de entrada, esto produce un aumento en la cola de carga del servidor haciendo de esta una solución poco rentable.

Como respuesta a este problema surge FastCGI que agiliza el proceso de ejecución de programas teniéndolos siempre funcionando y esperando las peticiones del servidor.

Otra solución es la de extender el servidor web con módulos que sirvan como interpretes y ejecutores para lenguajes no compilados, quizá el más popular sea el módulo del servidor web Apache para el lenguaje PHP, los inconvenientes de esta solución son que para cada lenguaje y para cada servidor se debe crear un interprete adicional y que no se puede implementar en lenguajes compilados(ej: C/C++, Java, etc).

La solución más inteligente es tener en el propio lenguaje un pequeño servidor web constante para generar los datos dinámicos y utilizar un servidor web más elaborado para los datos estáticos, adicional a esto unirlos detrás de un solo servidor utilizando un proxy inverso(algunos servidores web sirven también como proxy inverso) y puesto que para esta aplicación se necesita: un servidor para los webservices, otro para los archivos estáticos y otro para el servidor de envió de archivos (WebDAV), entonces esta solución se convierte en la más óptima partiendo del hecho de que el tiempo gastado en el proceso de comunicación entre el proxy inverso y los otros servidores es casi nulo, para el desarrollo de esta aplicación se ha desidido utilizar Pound como front-end de los servidores nombrados anteriormente.


\subsubsection{QooXdoo \cite{qooxdoo} }
\label{tec:qooxdoo}

QooXdoo es un framework de trabajo que está pensado para el desarrollo profesional en Javascript, contiene una conjunto de herramientas de alto nivel para el desarrollo de interfaces de usuario y de comunicación cliente-servidor, este framework no tiene dependencia alguna con el lenguaje utilizado en el lado del servidor, esto rompe con la tendencia de realizar proyectos AJAX para determinados lenguajes(ej: el toolkit de google para Java, Rails para Ruby, etc).

Las principales características de QooXdoo son:

\begin{itemize}

	\item Orientado a Objetos: a pesar de que JavaScript no es un lenguaje orientado a objetos del todo, qooxdoo incluye una implementación de los conceptos asociados con la programación orientada a objetos estos son: clases, objetos, mixins, interfaces, herencia, etc.
	
	\item Soporta múltiples navegadores: Firefox, Internet Explorer, Opera, Safari.
	
	\item Implementa un toolkit gráfico que esta a la par con toolkits de uso profesional como SWT(Java) o QT(C++, Python, Ruby, etc), en los que se incluye soporte para navegación por teclado, manejo del foco y del tabulador y manejo de drag and drop (arrastre y suelte).
	
	\item Contiene un optimizador y compresor (quitando cosas que no sirven como comentarios o saltos de linea y renombrando las variables por nombres más cortos) para el código JavaScript.
	
	\item Soporta I18N y localización.
	
	\item Tiene un sistema de pruebas automatizadas (test runner)
	
	\item Incluye soporte para programación orientada a eventos.

\end{itemize}


\subsubsection{Bases de datos}

Las base de datos de mayor uso en la actualidad son las base de datos relacionales, estas se fundamentan en el uso de ``relaciones'', las cuales podrán considerarse desde un punto de vista lógico como conjuntos de datos llamados ``tuplas'', en este modelo no importa el lugar ni la forma en que se almacenan los datos, teniendo como ventaja su fácil entendimiento y utilización para un usuario casual de la base de datos.

Otras bases de datos menos utilizadas, pero no por esto menos atractivas son:

\begin{itemize}

	\item Base de Datos Orientada a Objetos(OODB): En estas el sistema de consulta es orientado a objetos permitiendo patrones avanzados como herencia, encapsulamiento, paso de mensajes, etc.
	
	\item Base de Datos XML(XMLDB): El uso principal de XML es estructurar datos, recibirlos y enviarlos, pero también podemos guardar datos en nuestros documentos o una colección de ellos para que sean tratados luego con algún lenguaje o herramienta XML.

\end{itemize}


\subsubsection{Sistema de Archivos}

Los sistemas de archivos más comunes utilizan dispositivos de almacenamiento de datos que permiten el acceso a los datos como una cadena de bloques de un mismo tamaño, a veces llamados sectores. El software del sistema de archivos es responsable de la organización de estos sectores en archivos y directorios y mantiene un registro de que sectores pertenecen a que archivos y de que sectores no han sido utilizados aún.

En la practica, un sistema de archivos no requiere necesariamente de un dispositivo de almacenamiento físico, sino que puede ser utilizado también para acceder a datos como los generados dinámicamente, los recibidos a través de una conexión de red, un generador de números aleatorios o los de un sistema de configuración en donde cada parámetro es representado por un archivo y en donde las acciones de obtener o cambiar el valor del parámetro es equivalente a escribir o leer en los archivo.

En sistemas de archivos jerárquicos, usualmente, se declara la ubicación precisa de un archivo con una cadena de texto llamada ``ruta''. La nomenclatura para rutas varía ligeramente de sistema en sistema, pero mantienen por lo general una misma estructura. Una ruta viene dada por una sucesión de nombres de directorios y subdirectorios, ordenados jerárquicamente de izquierda a derecha y separados por algún carácter especial.


\subsubsection{Bases de Datos vs Sistemas de Archivos}

Debido a que los manejadores de versiones trabajan sobre sistemas de archivos, en el caso en que estos se encuentren en una base de datos, se nota inmediatamente una deficiencia en el tiempo requerido para procesar las acciones de administración de versiones en ellos ya que en algún punto se hace necesario moverlos desde la base de datos hacia el sistema de archivos.

Por esta razón para la realización del proyecto se ha tomado la decisión de no utilizar un manejador de base de datos, en lugar de esto se utilizará una jerarquía de archivos ordenada y bien definida.



\subsection{Marco Conceptual}

\subsubsection*{Reverse Proxy}

Un Proxy Inverso es un servidor proxy usado comúnmente como front-end (la parte visible) de uno o más servidores, funciona de forma opuesta a un servidor proxy regular ya que retransmite las conexiones entrantes desde Internet hacia los servidores (back-ends).\newline El proxy inverso puede lidiar con la petición o simplemente retransmitirla de forma parcial o total hacia los servidores.

Un proxy inverso se distingue por:

\begin{itemize}

	\item Cifrado de datos: el proxy inverso puede ser el encargado de realizar una conexión cifrada (SSL) con las máquinas clientes en el caso en que los servidores reales (back-ends) no puedan hacerlo o en el caso en que el proxy inverso disponga de hardware de cifrado que acelere el proceso.
	
	\item Seguridad: el servidor proxy inverso es una capa de defensa adicional.
	
	\item Distribución de carga: el servidor proxy inverso puede distribuir la carga hacia los servidores reales (back-ends), cada uno puede tener una parte de la información o simplemente distribuirla basado en la disponibilidad de los servidores.
	
	\item Caché: el servidor proxy inverso puede disminuir la carga de los servidores utilizando técnicas de caché de contenido estático.

\end{itemize}


\subsubsection*{CIFS(Common Internet File System)}

CIFS (Sistema de Archivos Común de Internet) es un protocolo de red que permite compartir archivos e impresoras (entre otras cosas) entre nodos de una red.\newline CIFS fue originalmente inventado por IBM con el nombre de SMB (Server Message Block), pero la versión más común hoy en día es la modificada ampliamente por Microsoft.\newline  Microsoft renombró SMB a Common Internet File System (CIFS) y añadió más características, que incluyen soporte para enlaces simbólicos, enlaces duros (hard links), y mayores tamaños de archivos.


\subsubsection*{Samba \cite{samba} }

Samba es una implementación libre del protocolo CIFS que funciona en sistemas operativos Unix.\newline Samba es realmente una implementación de muchos servicios y muchos protocolos, entre los que están: NetBIOS sobre TCP/IP (NetBT), SMB (también conocido como CIFS), DCE/RPC o más concretamente, MSRPC, el servidor WINS también conocido como el servidor de nombres NetBIOS (NBNS), los protocolos de dominio NT, con su sistema de autenticación a dominio, la base de datos del gestor de cuentas seguras (SAM), el servicio Local Security Authority (LSA) y el servicio de impresoras de NT. Todos estos servicios y protocolos son frecuentemente referidos de un modo incorrecto como NetBIOS o SMB.


\subsubsection*{CGI(Common Gateway Interface) - FCGI(Fast CGI)}

CGI(Interfaz de salida común) es un protocolo estándar para enlazar aplicaciones externas con un servidor de información (generalmente un servidor web), esto permite al servidor pasar las peticiones del cliente hacia la aplicación externa, en este caso el servidor puede retornar la salida de la aplicación hacia el cliente.

A pesar de que es muy sencillo modificar un programa para que sea funcional con CGI, surge un inconveniente y es que CGI necesita una copia completa de la ejecución del programa (un proceso) por cada petición, es por esto que la carga de trabajo se incrementa rápidamente en el servidor, como solución han surgido técnicas más eficientes como incluir un interprete del lenguaje a utilizar, como un módulo del servidor (por ejemplo mod\_php en apache) y otro menos utilizado pero no por eso menos eficiente FastCGI.

FastCGI surge como respuesta a la pérdida de eficiencia que se genera al utilizar CGI, FastCGI en lugar de crear un proceso por cada petición, permite utilizar varios procesos persistentes que manejen varias peticiones durante su ciclo de ejecución.


\subsubsection*{Control de Versiones}

Control de versiones se refiere al proceso de administrar múltiples revisiones de la misma unidad de información, es utilizada con mayor frecuencia en el desarrollo de software.
Debido a la naturaleza del desarrollo de software, múltiples programadores trabajando sobre múltiples archivos simultáneamente, surge la necesidad de llevar un control sobre quién, cuando y lo más importante cuales cambios se hacen sobre los archivos de código fuente.


\subsubsection*{Sistema de Control de Versiones}

Un sistema de control de versiones permite gestionar las versiones de todos los objetos de configuración que forman la linea base de un producto. Este tipo de sistemas facilitan la administración de las distintas versiones de cada producto desarrollado, junto a las posibles especializaciones realizadas para algún cliente especifico (Branch).

Los sistemas de control de versiones son utilizados principalmente en la industria del software para controlar las distintas versiones del código fuente, sin embargo, los mismos conceptos son aplicables en otros ámbitos no solo para código fuente sino para documentos en general, imágenes, etc.

Aunque el control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gestión entre las más populares se encuentran:

\begin{itemize}

	\item CVS \cite{cvs}
	\item SubVersion (SVN) \cite{svn}
	\item GIT \cite{git}
	\item Darcs \cite{darcs}
	\item BitKeeper \cite{bitkeeper}
	\item Mercurial (HG) \cite{mercurial}
	\item Source Safe \cite{ssafe}

\end{itemize}


Algunos sistemas de control de versiones utilizan un modelo de trabajo centralizado en donde todas las funciones de control son realizadas en un servidor compartido, si dos desarrolladores tratan de cambiar el mismo archivo al mismo tiempo sin un método de control de acceso, los desarrolladores podrían terminar sobrescribiendo el trabajo del otro, es por esto que los sistemas de control centralizados resuelven este problema utilizando 2 técnicas para el modelo de almacenamiento:

\begin{enumerate}

	\item Bloqueo de archivos: el bloqueo de archivos permite a un usuario impedir que otros obtengan y modifiquen una copia de una unidad de información determinada, asegurando así la integridad de los datos.
	
	\item Fusión de Versiones: algunos sistemas de control de versiones permiten que varios desarrolladores trabajen sobre una unidad de información al mismo tiempo, esto hace que el primer desarrollador en enviar los cambios no tenga ningún problema, sin embargo debe proveerse facilidades para que los siguientes cambios no eliminen los cambios enviados por el primer desarrollador.

\end{enumerate}

El otro tipo de sistema de control de versiones son los sistemas distribuidos, en los cuales existe una aproximación uno a uno contraria a la aproximación cliente-servidor de los sistemas centralizados, en lugar de que la información se centre en un único repositorio de donde los clientes se sincronizan, cada desarrollador posee una copia del repositorio del código.\newline En estos sistemas la sincronización es conducida por el intercambio de parches (conjuntos de cambios) entre los desarrolladores.

\subsubsection*{WYSIWYG (What You See Is What You Get)}

WYSIWYG. (Lo que ves es lo que obtienes) es un concepto aplicable a los editores de texto con formato (como por ejemplo un editor de HTML u OpenOffice.org) y en general a cualquier editor (ej: un editor de imágenes se puede considerar un editor WYSIWYG), el cual permite escribir un documento viendo inmediatamente el resultado final del mismo, es el editor el encargado de generar el código fuente (ej: HTML o Latex) o los archivos con formato (ej: una imagen).

Algunos ejemplos de editores WYSIWYG son:

\begin{itemize}

	\item NVU/Kompozer (HTML)
	\item Composer de Netscape y Mozilla (HTML)
	\item Lyx (latex)
	\item Krita (png, jpg, etc)
	\item Inkscape (svg, pdf, etc)

\end{itemize}


\subsubsection*{XP (Extreme Programming) \cite{xp} }

XP(Programación Extrema) es una disciplina de acercamiento al desarrollo de software, el éxito de XP se debe a que se centra en la satisfacción del cliente, la metodología es diseñada para entregar a los clientes el software que necesita en el momento en que lo necesita, su mayor ventaja es que puede responder al cambio de requerimientos del cliente incluso en momentos avanzados del ciclo de vida de la aplicación.

Esta metodología también hace énfasis en el trabajo en equipo en donde clientes, manejadores y desarrolladores hacen parte de un equipo dedicado a obtener software de calidad.

XP describe cinco tareas básicas en el proceso de desarrollo de software:

\paragraph{Codificar:} En XP lo más importante de un producto de software el es código, la codificación ayuda a comprender los verdaderos problemas del software a desarrollar, la codificación puede ser utilizada para conocer la solución más apropiada a un problema (ej: codificando todas las soluciones y determinando la mejor solución a partir de pruebas automatizadas)

\paragraph{Probar:} En XP las pruebas significan que un método no esta libre de errores hasta que no se pruebe lo contrario, por ello, se deben realizar pruebas unitarias y pruebas de aceptación acordadas con el cliente.

\paragraph{Escuchar:} En la mayoría de los casos el programador no conoce a ciencia cierta la lógica de negocio del sistema a desarrollar, la única forma de conocer la funcionalidad del sistema es escuchar al cliente y entender la lógica del negocio.

\paragraph{Diseñar:} Desde un punto de vista simple, se podría afirmar que el desarrollo de una aplicación no necesita más que codificar, probar y escuchar, si estas actividades se logran con éxito el resultado debe ser siempre un sistema que funcione bien, pero en la practica esto sencillamente no se da, se puede llegar muy lejos sin diseño pero en algún determinado momento se va a atascar, los sistemas tienden a ser complejos y por esto las dependencias internas deben quedar muy claras, un buen diseño evita estos problemas de dependencias, lo que significa que al cambiar una porción del sistema esta no afectará otras partes del mismo.

\paragraph{Buenas Practicas:} Las practicas a seguir en XP son 12 \cite{xp_practices} derivadas de ``best practices of software engineering'' \cite{best_practices}, las cuales aconsejan sobre técnicas probadas en otros problemas de desarrollo que han sido aplicadas con éxito.


\subsubsection*{RUP (Rational Unified Process) \cite{rup}}

El RUP (Proceso unificado de rational) es un proceso de desarrollo de software que se utiliza en conjunto con el lenguaje UML(Lenguaje Unificado de Modelado), este define una metodología para el análisis, implementación y documentación de sistemas orientados a objetos. RUP es en realidad un refinamiento realizado por Rational Software del original Proceso Unificado.

El ciclo de vida de RUP está basado en el desarrollo en espiral en este, el proceso se divide en ciclos iterativos en donde cada ciclo concluye cuando se obtiene un producto final, a su vez cada ciclo se divide en fases que finalizan con un hito (un momento en el que se debe tomar una decisión radical), estas fases son: 

\begin{enumerate}

	\item Concepción
	\item Elaboración
	\item Construcción
	\item Implementación

\end{enumerate}


\subsection{Estado del Arte}

En los últimos días las aplicaciones web se han visto afectadas por la adopción de una técnica conocida como AJAX, la cual añade la habilidad de cargar de forma dinámica partes de la interfaz, en este momento podemos ver aplicaciones muy útiles y fáciles de usar, las cuales accedemos totalmente utilizando únicamente el navegador, entre estas se destacan:


\paragraph{Writely: \cite{writely}} Es un procesador de textos, al cual se accede mediante el navegador, posee un interfaz AJAX y varias características adicionales como la posibilidad de añadir etiquetas (tags) a los documentos y la de compartir (ya sea para solo lectura o también para escritura) con otros usuarios.

\paragraph{Gmail: \cite{gmail}} Es un servicio de correo electrónico gratuito en etapa de pruebas (beta), que ha captado la atención de los medios de información por sus innovaciones tecnológicas, su capacidad y por algunas quejas de violación a la privacidad de los usuarios.

\paragraph{Google Calendar: \cite{google_calendar}} Es un servicio gratuito de calendarios en linea que permite mantener presente fácilmente fechas de cumpleaños, reuniones, búsqueda en Internet de eventos importantes, etc.

\paragraph{Flickr: \cite{flickr}} Es un sitio web de organización de fotografías digitales y red social. Fue desarrollado por Ludicorp, una empresa de Vancouver, Canadá, fundada en 2002. En marzo de 2005, Flickr y Ludicorp fueron compradas por Yahoo!. El servicio es utilizado extensamente por bloggers para el depósito de fotos. El sistema de Flickr permite hacer búsquedas de imágenes por etiquetas (tags), por fechas y por licencias.


En el mundo de los IDEs encontramos herramientas que han cambiado la forma en la que se diseñan y desarrollan las aplicaciones, los más importantes actualmente son:


\paragraph{Eclipse: \cite{eclipse}} Es un sistema multiplataforma libre que permite crear aplicaciones de cualquier tipo. La primera y más importante aplicación que ha sido realizada con este entorno es la afamado IDE Java llamado Java Development Toolkit (JDT) y el compilador utilizado para desarrollar el propio Eclipse, ambos están incluidos en el entorno.

\paragraph{Kdevelop: \cite{kdevelop}} Es un entorno integrado de desarrollo con licencia GPL para sistemas Linux y otros sistemas Unix, a diferencia de muchas otras interfaces de desarrollo, KDevelop no cuenta con un compilador propio, por lo que depende de compiladores externos para producir código binario. Su última versión se encuentra actualmente bajo desarrollo y soporta entre otros lenguajes de programación a C, C++, Java, SQL, Python, Perl, Pascal y Bash.

\paragraph{Visual Studio .NET: \cite{visual_studio}} Es un conjunto de herramientas integrado para la construcción y desarrollo de servicios web XML y soluciones Web, creado por Microsoft y ampliamente utilizado en el desarrollo de aplicaciones basadas en Windows.


Durante el proceso de desarrollo surgieron dos herramientas similares a la desarrollada, estas son:


\paragraph{Gyre:\cite{gyre}} Una herramienta que se basa en el desarrollo de aplicaciones web con el framework Ruby on Rails, esta herramienta se especializa de forma elegante en la depuración de dichas aplicaciones, incluyendo un depurador gráfico y un sistema de previsualización de resultados.

\paragraph{CodeIDE:\cite{codeide}} Esta herramienta se basa en la compilación y ejecución de varios lenguajes, entre los que se incluyen Basic, Pascal, ANSI C, Perl, JavaScript, HTML, MySQL, LISP y MATH, sin embargo por razones de seguridad los lenguajes no incluyen todas sus características, por esta misma razón y por que carece de un buen manejador de proyectos (manejo eficiente de múltiples archivos), resulta difícil realizar aplicaciones que sirvan para algo más que realizar cálculos o trabajar con cadenas de texto.


La aplicación desarrollada no tiene antecedentes registrados en el ámbito de integración del sistema de control de versiones, compilador y entorno de desarrollo centralizado accesible vía web.

