Duck typing is a principle of dynamic typing in which an object's current set of methods and properties determines the valid semantics, rather than its inheritance from a particular class.

The term is a reference to the duck test —

    When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

In this context though, it's more correct to say, "I can treat that bird as being like a duck, in at least some aspect".

Unfortunately the term has been popularised by its cute formation from a well-known quotation, rather than through its accuracy or ability to explain the concept. It's misleading in that it's usually applied to languages that actually contradict this "It's a duck" notion.

The scope of dynamic typing is just that of the method call(s), not the entire use of the object. For our purposes we don't care if the object supports both quacking and walking, just what's required at the time. It's fundamental that an inability to swim should not rule out use of the quack behaviour, even if it means that the object couldn't thus be "a true and complete duck".

Alex Martelli made an early (2000) use of the term in a message to the comp.lang.python newsgroup. He also highlighted this misunderstanding of the literal duck test, which may indicate that the term was already in use.[citation needed]

    In other words, don't check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc,
    depending on exactly what subset of duck-like behaviour you need to play your language-games with.

Languages (e.g. Java) may define interfaces which are then used in an inheritance-like manner. These are not usually considered to be duck typed languages. However if they implement a duck interface that defines the set of expected behaviours as a single unit, then they are actually closer to the literal "duck test" view than languages considered to be duck typed (e.g. Python) that test compatibility on a method-by-method basis, in a more truly dynamic manner.
Contents
[hide]

    * 1 Biological classification analogy
    * 2 Dynamic typing across languages
          o 2.1 In Python
          o 2.2 In PHP
          o 2.3 In Ruby
          o 2.4 In Perl
          o 2.5 In Java
          o 2.6 In Objective-C
          o 2.7 In ColdFusion
          o 2.8 Comparison with generics and structural subtyping
    * 3 References
    * 4 External links

[edit] Biological classification analogy

By analogy with scientific classification in biology, duck typing is a morphogenetic classification scheme. Object-oriented languages that use classical inheritance tend to take a phylogenetic approach to structuring software systems; that is, they classify objects in terms of their inheritance, or "is-a" relationships, and only objects of the same lineage can be substituted polymorphically.

Some languages, however, including those that use duck typing, allow morphogenetic classification; that is, they allow classification of objects in terms of their "shape" or how they "look". In software object terms, an object's "shape" is determined by its declared interface(s) (for example, in Java) or by the operations it supports (in duck typed languages). In duck typing, the actual inheritance of an object (or phylogeny) is of less importance than the way it "looks" (or morphology) to users of the object.

[edit] Dynamic typing across languages

Dynamic typing allows an object to be interchangeable with any other object so long as they both implement sufficiently useful interfaces, regardless of whether the objects have a related inheritance hierarchy. Duck typing is a feature of programming languages such as Smalltalk, Python, Objective-C, Ruby, JavaScript, and ColdFusion.

In Smalltalk, any object is interchangeable with any other at runtime. This is the most flexible kind of dynamic typing. Duck typing attempts to limit this flexibility while eliminating a source of possible errors before runtime. The Smalltalk architects sought to achieve true polymorphism at the expense of possible errors creeping in at runtime. In practice, these errors are dealt with, at runtime, via SUnit testing.

Abstract data types are static interfaces that exist only to guarantee, on paper, a particular interface. Smalltalk uses pure dynamic mechanisms, in a variety of ways, to extend the guarantee in practice. This can be as simple as generalizing the "method not found" exception handler into a catch-all lookup mechanism. But it can involve extending the language or environment, as in StrongTalk. Parallels to Smalltalk's exception handling came to be called duck typing in Java and Python, and a single reasonable syntax emerged.

C++ templates implement a static form of duck typing. An iterator, for example, does not inherit its methods from an Iterator base class.

Yet another approach similar to duck typing is OCaml's structural subtyping, where object types are compatible if their method signatures are compatible, regardless of their declared inheritance. This is all detected at compile time through OCaml's type inference system.


http://en.wikipedia.org/wiki/Duck_typing

















--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------












Este pequeño artículo explicativo está basado en el capítulo 23 de la segunda edición del Programming Ruby, de Dave Thomas.

“Si anda como un pato, nada como un pato y grazna como un pato, entonces es un pato”. Esa es la idea sobre la que se asienta la filosofía del duck typing, que propone atender a las capacidades de los objetos en lugar de a su clase a la hora de determinar su “tipo”.

En este pequeño artículo voy a intentar explicar un poco este concepto que, aunque simple en el fondo, ha llamado poderosamente mi atención. Como “rubista”, voy a apoyarme en Ruby para los ejemplos, pero el poco código que voy a mostrar será tremendamente simple (además de poco útil).

Un enfoque muy extendido y tradicional es considerar que, cuando hablamos de Programación Orientada a Objetos, la clase de un objeto viene a ser el equivalente a su tipo.

Sin embargo, según la filosofía duck typing, el tipo del objeto está determinado realmente por lo que el objeto puede hacer, no por su clase. Para aclararlo, veamos un poco de código (sin muchas pretensiones).

Siguiendo una filosofía tradicional, podríamos escribir código como este para concatenar dos cadenas:

def concatenar(a, b)
  unless a.kind_of?(String) and b.kind_of?(String)
    fail TypeError.new("Los parámetros deben ser String")
  end
  a << b
end

Comprobamos el “tipo” de los objetos considerando la clase a la que pertenecen. Pero, según el duck typing, su “tipo” está definido por el comportamiento. Este código respondería a esa filosofía:

def concatenar(a, b)
  unless a.respond_to?(:<<)
    fail TypeError.new("'a' debe soportar el método <<")
  end
  a << b
end

Muy bien, ¿y dónde está la gracia? ¿Qué hemos conseguido? En el primer ejemplo, teníamos un método capaz de concatenar cadenas. Sin embargo, en el segundo hemos conseguido un método que es capaz de añadir un objeto a otro que soporte el método <<, ya sea de la clase File, String, Array o cualquiera que implementemos nosotros mismos.

Así, todas estas llamadas al segundo método serían válidas:

puts concatenar("hola ", "y adiós")
puts concatenar([1, 2], 3).to_s
file = File.new('texto.txt', 'a')
concatenar(file, "prueba")
file.close
puts concatenar("a", 65)

Este ejemplo es un poco tonto, así que les animo a que busquen otras aplicaciones, porque les aseguro que es realmente útil poder pensar en términos de duck typing.

Antes de finalizar, no quisiera dejar pasar por alto un detalle: por lo general, al trabajar con lenguajes de tipado dinámico, no suele hacerse mucho hincapié en el control de los “tipos”. Así que, lo más normal, es que un método como el anterior se escriba así:

def concatenar(a, b)
  a << b
end

Muchos programadores, especialmente los que vienen del mundo de los lenguajes de tipado estático, piensan que esta “libertad” sólo induce a cometer más errores. Sin embargo, seguro que se sorprenderían al comprobar que esta clase de problemas aparecen rara vez y, por lo general, son fácilmente detectables y subsanables. Y, a cambio, se disfruta de una enorme flexibilidad.

¿Y a ustedes qué les parece? ¿Prefieren tipado estático o dinámico? ¿Aún son de los que piensan que los “lenguajes dinámicos” son de juguete? Y el duck typing: ¿lo encuentran útil?



http://devnull.blogs.banot.net/articles/2005/05/24/duck-typing-y-tipado-din%C3%A1mico
