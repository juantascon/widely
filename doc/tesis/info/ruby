Ruby (programming language)
From Wikipedia, the free encyclopedia
Jump to: navigation, search
Ruby
Paradigm: 	multi-paradigm (functional, imperative, logic, object-oriented (class-based))
Appeared in: 	1995
Designed by: 	Yukihiro Matsumoto
Developer: 	Yukihiro Matsumoto (among others)
Latest release: 	1.8.6 / March 12, 2007
Typing discipline: 	dynamic ("duck")
Major implementations: 	Ruby, JRuby
Influenced by: 	Smalltalk, Perl, Lisp, Scheme, Python, CLU, Dylan
Influenced: 	Groovy
OS: 	Cross-platform
License: 	Ruby License and GPL
Website: 	www.ruby-lang.org

Ruby is a reflective, dynamic, object-oriented programming language. It combines syntax inspired by Perl with Smalltalk-like object-oriented features, and also shares some features with Python, Lisp, Dylan, and CLU. Ruby is a single-pass interpreted language. Its official implementation is free software written in C.
Contents
[hide]

    * 1 History
    * 2 Philosophy
    * 3 Semantics
    * 4 Features
          o 4.1 Interaction
    * 5 Syntax
    * 6 "Gotchas"
          o 6.1 Language comparison
          o 6.2 Language features
    * 7 Examples
          o 7.1 Collections
          o 7.2 Blocks and iterators
          o 7.3 Classes
          o 7.4 Exceptions
          o 7.5 More examples
    * 8 Implementations
          o 8.1 Operating systems
          o 8.2 Licensing terms
    * 9 Criticism
    * 10 Repositories and libraries
    * 11 References
    * 12 See also
    * 13 External links

[edit] History
Yukihiro Matsumoto, the creator of Ruby.
Yukihiro Matsumoto, the creator of Ruby.

The language was created by Yukihiro "Matz" Matsumoto, who started working on Ruby on February 24, 1993, and released it to the public in 1995. "Ruby" was named as a gemstone because of a joke on Matz' internal circle of friends alluding to Perl's name. Coincidentally it turned out that a Ruby is the birthstone for July, while a Pearl is the one for June [1].

As of March 2007, the latest stable version is 1.8.6. Ruby 1.9 (with some major changes) is also in development. Performance differences between the current Ruby implementation and other more entrenched programming languages has led to the development of several virtual machines for Ruby. These include JRuby, a port of Ruby to the Java platform, IronRuby, an implementation for the .NET Framework produced by Microsoft, and Rubinius, an interpreter modeled after self-hosting Smalltalk virtual machines. The main developers have thrown their weight behind the virtual machine provided by the YARV project, which was merged into the Ruby source tree on 31 December 2006, and will be released as Ruby 2.0.

[edit] Philosophy

The language's creator has said that Ruby is designed for programmer productivity and fun, following the principles of good user interface design.[2] He stresses that systems design needs to emphasize human, rather than computer, needs [3]:
“ 	Often people, especially computer engineers, focus on the machines. They think, "By doing this, the machine will run faster. By doing this, the machine will run more effectively. By doing this, the machine will something something something." They are focusing on machines. But in fact we need to focus on humans, on how humans care about doing programming or operating the application of the machines. We are the masters. They are the slaves. 	”

Ruby is said to follow the principle of least surprise (POLS), meaning that the language should behave in such a way as to minimize confusion for experienced users. Matz has said his primary design goal was to make a language that he himself enjoyed using, by minimizing programmer work and possible confusion. He has said he hadn't applied the principle of least surprise to the design of Ruby,[4] but nevertheless the phrase has come to be closely associated with the Ruby programming language. The phrase has itself been a source of surprise, as novice users may take it to mean that Ruby's behaviors try to closely match behaviors familiar from other languages. In a May 2005 discussion on the comp.lang.ruby newsgroup, Matz attempts to distance Ruby from POLS, explaining that since any design choice will be surprising to someone, he uses a personal standard in evaluating surprise. If that personal standard remains consistent there will be few surprises for those familiar with the standard. [1]

Matz defined it this way in an interview [2]:
“ 	Everyone has an individual background. Someone may come from Python, someone else may come from Perl, and they may be surprised by different aspects of the language. Then they come up to me and say, 'I was surprised by this feature of the language, so Ruby violates the principle of least surprise.' Wait. Wait. The principle of least surprise is not for you only. The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well. For example, I was a C++ programmer before I started designing Ruby. I programmed in C++ exclusively for two or three years. And after two years of C++ programming, it still surprises me. 	”

[edit] Semantics

Ruby is object-oriented: every data type is an object, including even classes and types that many other languages designate as primitives (such as integers, booleans, and "nil"). Every function is a method. Named values (variables) always designate references to objects, not the objects themselves. Ruby supports inheritance with dynamic dispatch, mixins and singleton methods (belonging to, and defined for, a single instance rather than being defined on the class). Though Ruby does not support multiple inheritance, classes can import modules as mixins. Procedural syntax is supported, but all methods defined outside of the scope of a particular object are actually methods of the Object class. Since this class is parent to every other class, the changes become visible to all classes and objects.

Ruby has been described as a multi-paradigm programming language: it allows procedural programming (defining functions/variables outside classes makes them part of the root, 'self' Object), with object orientation (everything is an object) or functionally (it has anonymous functions, closures, and continuations; statements all have values, and functions return the last evaluation). It has support for introspection, reflection and metaprogramming, as well as support for threads[5]. Ruby features dynamic typing, and supports parametric polymorphism.

According to the Ruby FAQ [6], "If you like Perl, you will like Ruby and be right at home with its syntax. If you like Smalltalk, you will like Ruby and be right at home with its semantics. If you like Python, you may or may not be put off by the huge difference in design philosophy between Python and Ruby/Perl." [7]

[edit] Features

    * object-oriented
    * four levels of variable scope: global, class, instance, and local
    * exception handling
    * iterators and closures (based on passing blocks of code)
    * native, Perl-like regular expressions at the language level
    * operator overloading
    * automatic garbage collecting
    * highly portable
    * cooperative multi-threading on all platforms using Green threads
    * DLL/shared library dynamic loading on most platforms
    * introspection, reflection and metaprogramming
    * large standard library
    * supports dependency injection
    * continuations and generators (examples in RubyGarden: continuations and generators)

Ruby currently lacks full support for Unicode, though it has partial support for UTF-8.

[edit] Interaction

The Ruby official distribution also includes "irb", an interactive command-line interpreter which can be used to test code quickly. A session with this interactive program might be:

$ irb
irb(main):001:0> puts "Hello, World"
Hello, World
=> nil
irb(main):002:0> 1+2
=> 3

[edit] Syntax

The syntax of Ruby is broadly similar to Perl and Python. Class and method definitions are signaled by keywords. In contrast to Perl, variables are not obligatorily prefixed with a sigil. When used, the sigil changes the semantics of scope of the variable. The most striking difference from C and Perl is that keywords are typically used to define logical code blocks, without braces (i.e., pair of { and }). Line breaks are significant and taken as the end of a statement; a semicolon may be equivalently used. Unlike Python, indentation is not significant.

One of the differences of Ruby compared to Python and Perl is that Ruby keeps all of its instance variables completely private to the class and only exposes them through accessor methods (attr_writer, attr_reader, etc). Unlike the "getter" and "setter" methods of other languages like C++ or Java, accessor methods in Ruby can be written with a single line of code. As invocation of these methods does not require the use of parenthesis, it is trivial to change an instance variable into a full function, without modifying a single line of code or having to do any refactoring achieving similar functionality to C# and VB.NET property members. Python's property descriptors are similar, but come with a tradeoff in the development process. If one begins in Python by using a publicly exposed instance variable and later changes the implementation to use a private instance variable exposed through a property descriptor, code internal to the class may need to be adjusted to use the private variable rather than the public property. Ruby removes this design decision by forcing all instance variables to be private, but also provides a simple way to declare set and get methods. This is in keeping with the idea that in Ruby, one never directly accesses the internal members of a class from outside of it. Rather one passes a message to the class and receives a response.

See the examples section for samples of code demonstrating Ruby syntax.

[edit] "Gotchas"

[edit] Language comparison

Some features that differ notably from languages such as C or Perl:

    * Names that begin with a capital letter are treated as constants, so local variables should begin with a lowercase letter.
    * The symbols $ @ are not sigils as in Perl, but rather function as scope resolution operators.
    * To denote floating point numbers, one must follow with a zero digit (99.0) or an explicit conversion (99.to_f). It is insufficient to append a dot (99.) because numbers are susceptible to method syntax.
    * Boolean evaluation of non-boolean data is strict: 0, "" and [] are all evaluated to true. In C, the expression 0 ? 1 : 0 evaluates to 0 (i.e. false). In Ruby, however, it yields 1, as all numbers evaluate to true; only nil and false evaluate to false. A corollary to this rule is that Ruby methods by convention — for example, regular-expression searches — return numbers, strings, lists, or other non-false values on success, but nil on failure (e.g., mismatch). This convention is also used in Smalltalk, where only the special objects true and false can be used in a boolean expression.
    * Versions prior to 1.9 lack a character data type (compare to C, which provides type char for characters). This may cause surprises when slicing strings: "abc"[0] yields 97 (an integer, representing the ASCII code of the first character in the string); to obtain "a" use "abc"[0,1] (a substring of length 1) or "abc"[0].chr.
    * The notation "statement until expression", despite the English-language implication that statement would be executed at least once, and precedent in other languages' equivalent statements (e.g. "do { statement } while (not(expression));" in C/C++/...), actually never runs the statement if the expression is already true.
    * Unlike Python, Ruby doesn't have a syntax for named arguments in function invocation (calling a function by some_function(y=4, x=5) simply assigns 4 and 5 to the local variables y and x). This can be emulated, however, by passing hashes: some_function(:y => 4, :x => 5), however, and extracting the arguments by name inside the function, similar to Perl.

[edit] Language features

In addition, some issues with the language itself are commonly raised:

    * In terms of speed, Ruby's performance is inferior to that of many compiled languages (as is any interpreted language) and other major scripting languages such as Python and Perl[8]. However, in future releases (current revision: 1.9), Ruby will be bytecode compiled to be executed on YARV (Yet Another Ruby VM). Currently, Ruby's memory footprint for the same operations is lower than Perl's and Python's.[8]
    * Omission of parentheses around method arguments may lead to unexpected results if the methods take multiple parameters. Note that the Ruby developers have stated that omission of parentheses on multi-parameter methods may be disallowed in future Ruby versions. Much existing literature, however, encourages parenthesis omission for single-argument methods.

A list of "gotchas" may be found in Hal Fulton's book The Ruby Way, 2nd ed (ISBN 0-672-32884-4), Section 1.5. A similar list in the 1st edition pertained to an older version of Ruby (version 1.6), some problems of which have been fixed in the meantime. retry, for example, now works with while, until, and for, as well as iterators.

[edit] Examples

Classic Hello world example:

puts "Hello World!"

Some basic Ruby code:

# Everything, including a literal, is an object, so this works:
-199.abs                                                # 199
"ruby is cool".length                                   # 12
"Rick".index("c")                                       # 2
"Nice Day Isn't It?".downcase.split(//).uniq.sort.join  # " '?acdeinsty"

[edit] Collections

Constructing and using an array:

a = [1, 'hi', 3.14, 1, 2, [4, 5]]
 
a[2]           # 3.14
a.reverse      # [[4, 5], 2, 1, 3.14, 'hi', 1]
a.flatten.uniq # [1, 'hi', 3.14, 2, 4, 5]

Constructing and using a hash:

hash = {:water => 'wet', :fire => 'hot'}
puts hash[:fire] # Prints:  hot
 
hash.each_pair do |key, value| # Or:  hash.each do |key, value|
        puts "#{key} is #{value}"
end
 
# Prints:  water is wet
#          fire is hot
 
hash.delete_if {|key, value| key == :water} # Deletes :water => 'wet'

[edit] Blocks and iterators

The two syntaxes for creating a code block:

{ puts "Hello, World!" } # Note the { braces }
 
do puts "Hello, World!" end

Parameter-passing a block to be a closure:

# In an object instance variable (denoted with '@'), remember a block.
def remember(&a_block)
        @block = a_block
end
 
# Invoke the above method, giving it a block that takes a name.
remember {|name| puts "Hello, #{name}!"}
 
# When the time is right (for the object) -- call the closure!
@block.call("Jon")
# => "Hello, Jon!"

Returning closures from a method:

def create_set_and_get(initial_value=0) # Note the default value of 0
        closure_value = initial_value
        return Proc.new {|x| closure_value = x}, Proc.new { closure_value }
end
 
setter, getter = create_set_and_get  # ie. returns two values
setter.call(21)
getter.call # => 21

Yielding the flow of program control to a block which was provided at calling time:

def use_hello
        yield "hello"
end
 
# Invoke the above method, passing it a block.
use_hello {|string| puts string} # => 'hello'

Iterating over enumerations and arrays using blocks:

array = [1, 'hi', 3.14]
array.each {|item| puts item}
# => 1
# => hi
# => 3.14
 
(3..6).each {|num| puts num}
# => 3
# => 4
# => 5
# => 6

A method such as inject() can accept both a parameter and a block. Inject iterates over each member of a list, performing some function on while retaining an aggregate. This is analogous to the foldl function in functional programming languages. For example:

[1,3,5].inject(10) {|sum, element| sum + element} # => 19

On the first pass, the block receives 10 (the argument to inject) as sum, and 1 (the first element of the array) as element, This returns 11. 11 then becomes sum on the next pass, which is added to 3 to get 14. 14 is then added to 5, to finally return 19.

Blocks work with many built-in methods:

File.open('file.txt', 'w') do |file| # 'w' denotes "write mode".
        file.puts 'Wrote some text.'
end                                  # File is automatically closed here
 
File.readlines('file.txt').each do |line|
        puts line
end
# => Wrote some text.

Using an enumeration and a block to square the numbers 1 to 10:

(1..10).collect {|x| x*x} # => [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

[edit] Classes

The following code defines a class named Person. In addition to 'initialize', the usual constructor to create new objects, it has two methods: one to override the <=> comparison operator (so Array#sort can sort by age) and the other to override the to_s method (so Kernel#puts can format its output). Here, "attr_reader" is an example of metaprogramming in Ruby: "attr_accessor" defines getter and setter methods of instance variables, "attr_reader" only getter methods. Also, the last evaluated statement in a method is its return value, allowing the omission of an explicit 'return'.

class Person
        def initialize(name, age)
                @name, @age = name, age
        end
        def <=>(person) # Comparison operator for sorting
                @age <=> person.age
        end
        def to_s
                "#@name (#@age)"
        end
        attr_reader :name, :age
end
 
group = [
        Person.new("Jon", 20), 
        Person.new("Marcus", 63), 
        Person.new("Ash", 16) 
]
 
puts group.sort.reverse

The above prints three names in reverse age order:

Marcus (63)
Jon (20)
Ash (16)

[edit] Exceptions

An exception is raised with a raise call:

raise

An optional message can be added to the exception:

raise "This is a message"

You can also specify which type of exception you want to raise:

raise ArgumentError, "Illegal arguments!"

Exceptions are handled by the rescue clause. Such a clause can catch exceptions that inherit from StandardError:

begin
# Do something
rescue
# Handle exception
end

Note that it is a common mistake to attempt to catch all exceptions with a simple rescue clause. To catch all exceptions one must write:

begin
# Do something
rescue Exception # don't write just rescue -- this only catches StandardError, a subclass of Exception
# Handle exception
end

Or catch particular exceptions:

begin
# ...
rescue RuntimeError 
# handling
end

Finally, it is possible to specify that the exception object be made available to the handler clause:

begin
# ...
rescue RuntimeError => e
# handling, possibly involving e
end

Alternatively, the most recent exception is stored in the magic global $!.

[edit] More examples

More sample Ruby code is available as algorithms in the following articles:

    * Exponentiating by squaring
    * Ruby associative arrays
    * Trabb Pardo-Knuth algorithm

[edit] Implementations

Ruby has two main implementations: the official Ruby interpreter, which is the most widely used, and JRuby, a Java-based implementation.

There are other less known implementations such as IronRuby (still unreleased yet), Rubinius, XRuby and YARV. YARV is sometimes referred as the next official Ruby engine.

[edit] Operating systems

Ruby is available for the following operating systems:

    * Acorn RISC OS
    * Amiga
    * BeOS
    * DOS
    * Linux
    * Mac OS X
    * Microsoft Windows 95/98/XP/NT/2000/2003/Vista
    * Microsoft Windows CE
    * MorphOS
    * OS/2
    * OpenVMS
    * Syllable
    * Symbian OS
    * Blue Gene/L compute node kernel
    * Most flavors of Unix

Other ports may also exist.

[edit] Licensing terms

The Ruby interpreter and libraries are distributed disjointedly (dual licensed) under the free and open source licenses GPL and Ruby License [9].

[edit] Criticism

The current 1.8 version of Ruby main interpreter has some limitations. On 1 January 2007, work has begun for version 1.9 which will produce Ruby 2.0 later in 2007 or in 2008. The problems of the current stable version include:

    * As a dynamic scripting language, Ruby's speed is much less than that of other languages, including scripting languages such as Perl, PHP, or Python [3] [4] - however, the next version of Ruby will include a new faster interpreter, YARV
    * The Ruby threading model uses Green threads [5], and its model has some inherent limitations that render it difficult to use or unsafe for some user-case scenarios [6] - however, version 2.0 of Ruby will not implement green threads.
    * Ruby does not yet have native support for Unicode or multibyte strings [7] (expected in version 2.0)

Some problems that may not be solved in version 2.0 include:

    * Ruby still lacks a specification, the current reference specification being de facto C implementation [8] [9] .



http://en.wikipedia.org/wiki/Ruby_%28programming_language%29

